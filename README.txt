This is a smart contract that acts as an off-chain signature-based shared wallet amongst different signers that showcases use of meta-transaction knowledge and ECDSA recover(). 
 bytes[] memory signatures is then passed into executeTransaction as well as the necessary info to use recover() to obtain the public address that ought to line up with one of the signers of the wallet.
        This method, plus some conditional logic to avoid any duplicate entries from a single signer, is how votes for a specific transaction (hashed tx) are assessed.
    If it's a success, the tx is passed to the call(){} function of the deployed MetaMultiSigWallet contract (this contract), thereby passing the onlySelf modifier for any possible calls to internal txs such as (addSigner(),removeSigner(),transferFunds(),updateSignaturesRequried()).
